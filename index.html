<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fox Hunt</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 20px;
            background-color: #f0f0f0;
            color: #333;
        }

        h1 {
            color: #333;
        }

        #game-info {
            margin-bottom: 15px;
            font-size: 1.1em;
            min-height: 80px; /* Adjusted for more text */
            text-align: center;
        }

        #game-grid {
            border-collapse: collapse;
            border: 2px solid #333;
            margin-bottom: 20px;
            box-shadow: 0 0 10px rgba(0,0,0,0.2);
            user-select: none; /* Prevent text selection on clicks */
        }

        #game-grid td {
            width: 40px;
            height: 40px;
            border: 1px solid #ccc;
            text-align: center;
            vertical-align: middle;
            font-weight: bold;
            cursor: pointer;
            background-color: #fff;
            transition: background-color 0.3s, color 0.3s;
            position: relative; /* For positioning marks */
        }

        #game-grid td:hover {
            background-color: #e0e0e0;
        }

        #game-grid td .game-content {
            display: inline-block;
            font-size: 1.2em;
        }
        
        #game-grid td .cell-mark {
            position: absolute;
            top: 1px;
            right: 3px;
            font-size: 0.6em;
            color: #007bff; /* Blue for marks */
            pointer-events: none; /* Marks should not interfere with cell clicks */
        }

        #game-grid td.probed {
            background-color: #a7c7e7; /* Light blue */
            cursor: default;
        }
        #game-grid td.probed .game-content {
             color: #000;
        }

        #game-grid td.found {
            background-color: #90ee90; /* Light green */
            cursor: default;
        }
        #game-grid td.found .game-content {
            font-size: 1.5em; /* Make fox emoji bigger */
        }

        #reset-button {
            padding: 10px 20px;
            font-size: 1em;
            color: white;
            background-color: #007bff;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        #reset-button:hover {
            background-color: #0056b3;
        }
    </style>
</head>
<body>
    <h1>Fox Hunt</h1>

    <div id="game-info">
        <p id="status-text">Loading game...</p>
        <p id="probes-text">Probes: 0</p>
        <p style="font-size: 0.9em;">
            Find 8 foxes on a 10x10 grid. The number in a cell indicates total foxes (found or not) on its row, column, & diagonals. <br>
            Left-click to probe. Right-click to mark a cell (0, 1, 2...), middle-click to clear mark.
        </p>
    </div>

    <table id="game-grid"></table>

    <button id="reset-button">Start Over</button>

    <script>
        const GRID_SIZE = 10;
        const NUM_FOXES = 8;
        const FOX_ICON = 'ðŸ¦Š';

        let foxes = []; // Array of {row, col, id, found: false}
        let foundFoxesCount = 0;
        let gridCellReferences = []; // 2D array of {td, gameContentSpan, markSpan}
        let cellMarks = []; // 2D array for numerical marks (null if no mark, then 0, 1, 2...)
        let gameIsOver = false;
        let probesMade = 0;

        const gameGridElement = document.getElementById('game-grid');
        const statusTextElement = document.getElementById('status-text');
        const probesTextElement = document.getElementById('probes-text');
        const resetButtonElement = document.getElementById('reset-button');

        function initGame() {
            foxes = [];
            foundFoxesCount = 0;
            gridCellReferences = [];
            cellMarks = []; 
            for (let r = 0; r < GRID_SIZE; r++) {
                // UPDATED: Initialize with null for no mark
                cellMarks[r] = Array(GRID_SIZE).fill(null); 
            }
            gameIsOver = false;
            probesMade = 0;
            gameGridElement.innerHTML = ''; 

            createGrid();
            placeFoxes(); // This will now place foxes in unique cells
            updateStatusDisplay();
            // For debugging:
            // console.log("Foxes placed at:", foxes.map(f => `(${f.row},${f.col}) ID:${f.id}`).join('; '));
        }

        function createGrid() {
            for (let r = 0; r < GRID_SIZE; r++) {
                const rowElement = gameGridElement.insertRow();
                gridCellReferences[r] = [];
                
                for (let c = 0; c < GRID_SIZE; c++) {
                    const cellTd = rowElement.insertCell();
                    cellTd.dataset.row = r;
                    cellTd.dataset.col = c;

                    const gameContentSpan = document.createElement('span');
                    gameContentSpan.classList.add('game-content');
                    cellTd.appendChild(gameContentSpan);

                    const markSpan = document.createElement('span');
                    markSpan.classList.add('cell-mark');
                    cellTd.appendChild(markSpan);
                    
                    const cellRef = { td: cellTd, gameContent: gameContentSpan, mark: markSpan };
                    gridCellReferences[r][c] = cellRef;

                    cellTd.addEventListener('click', () => handleCellClick(r, c, cellRef));
                    cellTd.addEventListener('contextmenu', (event) => handleRightClick(event, r, c, cellRef));
                    cellTd.addEventListener('auxclick', (event) => handleMiddleClick(event, r, c, cellRef)); // Middle click
                }
            }
        }

        // UPDATED: Ensures foxes are placed in unique cells
        function placeFoxes() {
            const occupiedCells = new Set(); // Stores "row,col" strings to track occupied cells

            for (let i = 0; i < NUM_FOXES; i++) {
                let row, col, cellKey;
                do {
                    row = Math.floor(Math.random() * GRID_SIZE);
                    col = Math.floor(Math.random() * GRID_SIZE);
                    cellKey = `${row},${col}`;
                } while (occupiedCells.has(cellKey)); // Loop until an empty cell is found

                foxes.push({ row, col, id: i, found: false });
                occupiedCells.add(cellKey);
            }
        }

        function handleCellClick(row, col, cellRef) {
            if (gameIsOver || cellRef.td.classList.contains('probed') || cellRef.td.classList.contains('found')) {
                return; 
            }

            probesMade++; 

            // Since foxes are in unique cells, directHits will be 0 or 1
            let directHit = false;
            foxes.forEach(fox => {
                if (fox.row === row && fox.col === col && !fox.found) {
                    fox.found = true;
                    foundFoxesCount++;
                    directHit = true;
                }
            });

            if (directHit) {
                cellRef.gameContent.textContent = FOX_ICON; // Only one fox per cell possible now
                cellRef.td.classList.add('found');
            } else {
                const pelengCount = calculatePeleng(row, col);
                cellRef.gameContent.textContent = pelengCount;
                cellRef.td.classList.add('probed');
            }
            
            // Clear any user marks on probed/found cells
            if (cellMarks[row][col] !== null) {
                cellMarks[row][col] = null;
                cellRef.mark.textContent = '';
            }

            updateStatusDisplay();
            checkWin();
        }

        // UPDATED: Right-click to mark, starts with '0'
        function handleRightClick(event, row, col, cellRef) {
            event.preventDefault(); 
            if (gameIsOver || cellRef.td.classList.contains('probed') || cellRef.td.classList.contains('found')) {
                return; // Don't mark probed or found cells
            }

            if (cellMarks[row][col] === null) {
                cellMarks[row][col] = 0; // First mark is '0'
            } else {
                cellMarks[row][col]++; // Increment existing mark
            }
            cellRef.mark.textContent = cellMarks[row][col];
        }

        // UPDATED: Middle-click to clear mark
        function handleMiddleClick(event, row, col, cellRef) {
            if (event.button === 1) { // Middle mouse button
                event.preventDefault();
                if (gameIsOver || cellRef.td.classList.contains('probed') || cellRef.td.classList.contains('found')) {
                    return; // Don't unmark probed or found cells
                }
                
                cellMarks[row][col] = null; // Reset mark to null (no mark)
                cellRef.mark.textContent = ''; 
            }
        }

        function calculatePeleng(probeRow, probeCol) {
            const uniqueFoxIDsOnLines = new Set(); 

            foxes.forEach(fox => {
                // The rule is that peleng counts all foxes (found or not)
                // if (fox.found) return; // This line was correctly removed/commented in your provided code

                const isOnRow = fox.row === probeRow;
                const isOnCol = fox.col === probeCol;
                const isOnDiagonal1 = (fox.row - fox.col) === (probeRow - probeCol);
                const isOnDiagonal2 = (fox.row + fox.col) === (probeRow + probeCol);

                if (isOnRow || isOnCol || isOnDiagonal1 || isOnDiagonal2) {
                    uniqueFoxIDsOnLines.add(fox.id); 
                }
            });
            return uniqueFoxIDsOnLines.size;
        }

        function updateStatusDisplay() {
            probesTextElement.textContent = `Probes: ${probesMade}`;
            if (gameIsOver) {
                // Status text is set by checkWin when game ends
                return;
            }

            const foxesRemaining = NUM_FOXES - foundFoxesCount;
            if (foxesRemaining > 0) {
                statusTextElement.textContent = `Foxes remaining: ${foxesRemaining}`;
            }
        }

        function checkWin() {
            if (foundFoxesCount === NUM_FOXES && !gameIsOver) { 
                gameIsOver = true;
                statusTextElement.textContent = `Congratulations! All ${NUM_FOXES} foxes found in ${probesMade} probes!`;
                revealAllFoxes(); 
            }
        }
        
        function revealAllFoxes() { 
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    const cellRef = gridCellReferences[r][c];
                    if (cellRef.td.classList.contains('found') || cellRef.td.classList.contains('probed')) {
                        continue; 
                    }

                    // Since foxes are unique, at most one fox per cell
                    let foxInCell = false;
                    foxes.forEach(fox => { 
                        if (fox.row === r && fox.col === c) { // No need to check !fox.found, reveal all
                            foxInCell = true;
                        }
                    });

                    if (foxInCell) { 
                        cellRef.gameContent.textContent = FOX_ICON;
                        cellRef.td.classList.add('found'); // Visually mark as found
                        // Optional: different style for revealed-at-end-not-by-player
                        cellRef.td.style.backgroundColor = "#ffdddd"; // Light red for revealed
                    }
                }
            }
        }

        resetButtonElement.addEventListener('click', initGame);
        document.addEventListener('DOMContentLoaded', initGame);
    </script>
</body>
</html>
